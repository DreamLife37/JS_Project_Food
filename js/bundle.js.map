{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,8GAA8G;AAC9G,UAAU;AACV,+GAA+G;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA,qFAAqF;AACrF;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,YAAY;AACZ,SAAS;AACT;AACA;AACA;AACA,wDAAwD,gBAAgB,OAAO;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,cAAc;AACd;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,IAAI;;;;;;;;;;;;;;;AC9I8B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC,oCAAoC;AACpC;AACA,kEAAkE;AAClE;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,wBAAwB;AACxB,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,UAAU,MAAM,SAAS;AACxD,sDAAsD,WAAW;AACjE,oDAAoD,WAAW;AAC/D;AACA;AACA;AACA,8DAA8D,WAAW;AACzE;AACA;AACA,eAAe;AACf,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO,IAAI,kCAAkC;AAC9D;AACA,iBAAiB;AACjB,aAAa,GAAG;AAChB;AACA;AACA,IAAI,+DAAW;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO,IAAI,kCAAkC;AAC1D;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,KAAK,MAAM,OAAO;AACzC,8CAA8C,MAAM;AACpD,4CAA4C,MAAM;AAClD;AACA;AACA;AACA,sDAAsD,MAAM;AAC5D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK;;;;;;;;;;;;;;;;AC1K0B;AACA;AAC9C;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,iDAAiD;AACjD;AACA,gCAAgC;AAChC;AACA,+DAA+D;AAC/D;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,kDAAkD;AAClD,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E,0CAA0C;AAC1C;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,cAAc,GAAG;AACjB;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,kCAAkC;AAClC;AACA,YAAY,4DAAQ;AACpB;AACA;AACA,uCAAuC;AACvC,sDAAsD;AACtD;AACA,iBAAiB,gBAAgB;AACjC;AACA,iBAAiB,kBAAkB;AACnC,kCAAkC;AAClC,iBAAiB;AACjB;AACA;AACA,sDAAsD;AACtD;AACA;AACA,0DAA0D;AAC1D,8CAA8C;AAC9C;AACA,sCAAsC;AACtC,2BAA2B;AAC3B,sBAAsB;AACtB,0DAA0D;AAC1D;AACA,iBAAiB,IAAI;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA,+CAA+C;AAC/C,QAAQ,iDAAS,0BAA0B;AAC3C;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,YAAY,kDAAU;AACtB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,eAAe;AACf,yBAAyB;AACzB;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK;;;;;;;;;;;;;;;;AChLpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,oDAAoD;AACpD,WAAW;AACX;AACA,uDAAuD;AACvD,wCAAwC;AACxC,2CAA2C;AAC3C,8CAA8C;AAC9C,QAAQ,KAAK;AACb;AACA;AACA;AACA;AACA,KAAK,GAAG;AACR;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,sDAAsD;AACtD,SAAS;AACT;AACA;AACA;AACA,4CAA4C;AAC5C,qDAAqD;AACrD,yCAAyC;AACzC;AACA;AACA,gCAAgC;AAChC,4CAA4C;AAC5C,+CAA+C;AAC/C;AACA;AACA;AACA,2DAA2D;AAC3D;AACA,6CAA6C;AAC7C;AACA;AACA,+EAA+E;AAC/E;AACA;AACA,uCAAuC;AACvC;AACA,KAAK;AACL;AACA,kDAAkD;AAClD;AACA,uEAAuE;AACvE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA,0DAA0D;AAC1D;AACA;AACA,iEAAe,KAAK,EAAC;AACD;;;;;;;;;;;;;;;ACnHpB,iBAAiB,qFAAqF,IAAI;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,gCAAgC,cAAc;AAC9C,kCAAkC,WAAW;AAC7C,MAAM;AACN;AACA;AACA;AACA,yDAAyD;AACzD,wCAAwC;AACxC,+CAA+C;AAC/C,6CAA6C;AAC7C,8BAA8B;AAC9B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC,kDAAkD;AAClD,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,6CAA6C;AAC7C;AACA,qDAAqD,OAAO,KAAK;AACjE;AACA,2CAA2C;AAC3C;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD,WAAW;AACX;AACA;AACA,wDAAwD;AACxD,iDAAiD;AACjD;AACA;AACA,KAAK;AACL;AACA;AACA,2BAA2B;AAC3B;AACA,UAAU;AACV,6CAA6C;AAC7C;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,yDAAyD,OAAO;AAChE;AACA;AACA,4CAA4C,WAAW;AACvD,gBAAgB;AAChB;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,yBAAyB;AACzB;AACA,sCAAsC,WAAW;AACjD,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW;AACnD,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO,GAAG;AACV;AACA;AACA;AACA,iEAAe,MAAM;;;;;;;;;;;;;;AClNrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA,UAAU,cAAc,MAAM,aAAa,MAAM,qBAAqB,0BAA0B,gBAAgB,KAAK,cAAc,GAAG;AACtI;AACA;AACA,gCAAgC;AAChC,sCAAsC;AACtC,4CAA4C;AAC5C,wCAAwC;AACxC,mDAAmD;AACnD,SAAS;AACT;AACA,gDAAgD;AAChD,SAAS;AACT;AACA;AACA,qCAAqC;AACrC,kDAAkD;AAClD,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sCAAsC;AACtC,uCAAuC;AACvC;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA,iEAAe,IAAI;;;;;;;;;;;;;;ACvDnB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,oCAAoC;AACpC,uBAAuB,IAAI,GAAG;AAC9B,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA,uBAAuB;AACvB;AACA,iCAAiC;AACjC,kDAAkD;AAClD;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,iEAAe,KAAK;;;;;;;;;;;;;;;AC7DpB;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,mCAAmC;AACnC;AACA,mBAAmB;AACnB;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,2CAA2C,IAAI,YAAY,WAAW,IAAI;AAC1E;AACA,6BAA6B;AAC7B;AACA;AACkB;AAClB;;;;;;;UC7BA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;ACNkC;AACE;AACA;AACA;AACF;AACE;AACE;AACI;AAC1C;AACA;AACA;AACA;AACA,0CAA0C,yDAAS,kCAAkC;AACrF,IAAI,sDAAI;AACR,IAAI,uDAAK;AACT,IAAI,uDAAK;AACT,IAAI,uDAAK;AACT,IAAI,sDAAI;AACR,IAAI,uDAAK;AACT,IAAI,wDAAM,GAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,E","sources":["webpack://food/./js/modules/calc.js","webpack://food/./js/modules/cards.js","webpack://food/./js/modules/forms.js","webpack://food/./js/modules/modal.js","webpack://food/./js/modules/slider.js","webpack://food/./js/modules/tabs.js","webpack://food/./js/modules/timer.js","webpack://food/./js/services/services.js","webpack://food/webpack/bootstrap","webpack://food/webpack/runtime/define property getters","webpack://food/webpack/runtime/hasOwnProperty shorthand","webpack://food/webpack/runtime/make namespace object","webpack://food/./js/script.js"],"sourcesContent":["function calc() {\r\n    //калькулятор переписывать не стали, тк здесь много различных селекторов, параметров, и они редко похожи друг на друга и врятли будет ситуация в переиспользовании его.\r\n    \r\n     // Calculator. Создание калькулятора часть 1. 066\r\n\r\n    //в html добавляем уникальный идентификатор female и male, также пропишем каждому уровню активности data атрибут (data-ratio) с определенным значением.\r\n\r\n    const result = document.querySelector('.calculating__result span'); //находим класс и внутри него получаем span (текстовое поле)\r\n\r\n    let sex, height, weight, age, ratio\r\n\r\n    //067 Если в localStorage есть значения взять их оттуда, иначе установить дефолтные\r\n    if (localStorage.getItem('sex')) {\r\n        sex = localStorage.getItem('sex');\r\n    } else {\r\n        sex = 'female';\r\n        localStorage.setItem('sex', 'female');\r\n    }\r\n\r\n    if (localStorage.getItem('ratio')) {\r\n        ratio = localStorage.getItem('ratio');\r\n    } else {\r\n        ratio = '1.375';\r\n        localStorage.setItem('ratio', '1.375');\r\n    }\r\n\r\n    //067 Функция по установке класса активности из localStorage\r\n    function initLocalSettings(selector, activeClass) {\r\n        const elements = document.querySelectorAll(selector);\r\n        elements.forEach(elem => {\r\n            elem.classList.remove(activeClass);\r\n            //добавляем условия, чтобы не писать 2 функции\r\n            if (elem.getAttribute('id') === localStorage.getItem('sex')) {\r\n                elem.classList.add(activeClass);\r\n            } \r\n            if (elem.getAttribute('data-ratio') === localStorage.getItem('ratio')) {\r\n                elem.classList.add(activeClass);\r\n            }\r\n        })\r\n    }\r\n    //Функция сначала перебирает пол, далее вызываем и перебираем активность\r\n    //Тк мы обращаемся к блокам, то указываем div \r\n    initLocalSettings('#gender div', 'calculating__choose-item_active');\r\n    initLocalSettings('.calculating__choose_big div', 'calculating__choose-item_active');\r\n\r\n    //В 1-ом и 3-ем блоке будет одна функция, которая будет брать значение из div. А вторая функция будет работать с input во втором блоке.\r\n    function calcTotal() {\r\n        //если нет пола или роста или веса или возраста или коэфициента, то расчет производить не будем\r\n        if (!sex || !height || !weight || !age || !ratio) {\r\n            result.textContent = '____';\r\n            return; //return прерывает дальнейшие действия\r\n        }\r\n        if (sex === 'female') {\r\n            result.textContent = Math.round((447.6 + (9.2 * weight) + (3.1 * height) - (4.3 * age)) * ratio); //формула для женщин\r\n        } else {\r\n            result.textContent = Math.round((88.36 + (13.4 * weight) + (4.8 * height) - (5.7 * age)) * ratio); //формула для мужщин\r\n        }\r\n    }\r\n\r\n    calcTotal();\r\n\r\n    //Функция по получению статических данных: пол и физическая активность\r\n    //С такой записью функции будет баг при клике мимо кнопки, на подложку\r\n    /*    function getStaticInformation(parentSelector, activeClass) {\r\n           const elements = document.querySelectorAll(`${parentSelector} div`);\r\n           //делигирование событий, на родителя вешаем обработчик события:\r\n           document.querySelector(parentSelector).addEventListener('click', (e) => { //если у блока по поторому мы кликнули есть атрибут data-ratio, то изменяем переменную ratio\r\n               if (e.target.getAttribute('data-ratio')) {\r\n                   ratio = +e.target.getAttribute('data-ratio');\r\n               } else {\r\n                   sex = e.target.getAttribute('id');\r\n               }\r\n               console.log(ratio, sex)\r\n               //перебираем все элементы и удаляем класс активности, а объекту события, по которому кликнули назначаем класс активности\r\n               elements.forEach(elem => {\r\n                   elem.classList.remove(activeClass)\r\n               })\r\n               e.target.classList.add(activeClass);\r\n               calcTotal();\r\n           });\r\n       } */\r\n\r\n    //исправление бага при клике на подложку кнопок,это происходит из-за того, что мы используем дилигирование событий (запись выше), лучше вместо этого использовать простое навешивание событий.Для этого мы перебираем все элементы внутри и на каждый из них вешаем обработчик события\r\n    function getStaticInformation(selector, activeClass) {\r\n        //const elements = document.querySelectorAll(`${parentSelector} div`); //получение внутри родителя всех div\r\n        const elements = document.querySelectorAll(selector);\r\n        elements.forEach(elem => {\r\n            elem.addEventListener('click', (e) => {\r\n                //если у блока по поторому мы кликнули есть атрибут data-ratio, то изменяем переменную ratio\r\n                if (e.target.getAttribute('data-ratio')) {\r\n                    ratio = +e.target.getAttribute('data-ratio');\r\n                    //067 Сохранение выбранных пользователем параметров в LocalStorage\r\n                    localStorage.setItem('ratio', +e.target.getAttribute('data-ratio'));\r\n                } else {\r\n                    sex = e.target.getAttribute('id');\r\n                    localStorage.setItem('sex', e.target.getAttribute('id')); //067\r\n                }\r\n                console.log(ratio, sex)\r\n                //перебираем все элементы и удаляем класс активности, а объекту события, по которому кликнули назначаем класс активности\r\n                elements.forEach(elem => {\r\n                    elem.classList.remove(activeClass)\r\n                })\r\n                e.target.classList.add(activeClass);\r\n                calcTotal();\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n    getStaticInformation('#gender div', 'calculating__choose-item_active');\r\n    getStaticInformation('.calculating__choose_big div', 'calculating__choose-item_active');\r\n\r\n    function getDynamicInformation(selector) {\r\n        const input = document.querySelector(selector);\r\n        input.addEventListener('input', () => {\r\n            //067 Проверка на ввод не числа\r\n            if (input.value.match(/\\D/g)) {\r\n                input.style.border = '2px solid red'; //обвести поле красным\r\n            } else {\r\n                input.style.border = 'none';\r\n            }\r\n\r\n            switch (input.getAttribute('id')) { //если id равно росту, то записываем значение в рост и тд.\r\n                case 'height':\r\n                    height = +input.value;\r\n                    break;\r\n                case 'weight':\r\n                    weight = +input.value;\r\n                    break;\r\n                case 'age':\r\n                    age = +input.value;\r\n                    break;\r\n            }\r\n            calcTotal(); //фунция конечного расчета должна вызываться каждый раз когда происходит какое то изменение на странице\r\n        });\r\n\r\n    }\r\n    getDynamicInformation('#height');\r\n    getDynamicInformation('#weight');\r\n    getDynamicInformation('#age');\r\n}\r\n\r\nexport default calc;","import {getResourse} from '../services/services';\r\n\r\nfunction cards() {\r\n    //Задание 048. Используем классы для карточек\r\n\r\n    //реализации карточек с классом (059 вер 1), для второго варианта не нужно\r\n    //Создаем шаблон (класс), чтобы от него отпачковывать карточки\r\n    class MenuCard { //название класса всегда с большой буквы\r\n        constructor(src, alt, title, descr, price, parentSelector, ...classes) {\r\n            //прописываем свойства\r\n            this.src = src; //источник картинки\r\n            this.alt = alt; //альтернативный текст картинки\r\n            this.title = title; //заголовок\r\n            this.descr = descr; //описание\r\n            this.price = price; //цена\r\n            this.classes = classes; //это будет массив, а не обычные строки\r\n            //parentSelector-родитель для карточек, те место куда мы их помещаем\r\n            this.parent = document.querySelector(parentSelector); //в свойстве this.parent лежит DOM элемент\r\n            //Нам нужно получить один элемент, внутрь вставляем parentSelector который мы будем передавать в настройку нашего класса\r\n            this.transfer = 27; //курс конвертации валюты\r\n            this.changeToUAH();\r\n        }\r\n\r\n        //Создаем методы:\r\n        changeToUAH() { //создаем метод конвертации валюты в гривну из USD\r\n            this.price = this.price * this.transfer; // (цена придет на как аргумент*на курс конвертации)\r\n        }\r\n        render() {\r\n            /*//создаем метод для вестки\r\n                       1) создание элемента\r\n                       2) в созданный элемент помещаем вестку (копируем из html файла)\r\n                       3) верстку дополнить данными которые приходят как аргументы\r\n                       4) поместить элемент на страницу */\r\n            const element = document.createElement('div');\r\n            //classes (rest) всегда будет сформировывать массив, даже если мы не передадим аргумент, то массив будет пустой\r\n            if (this.classes.length === 0) { //если кол-во элементов в массиве =0,то присваиваем стандартное значение\r\n                this.element = 'menu__item';\r\n                element.classList.add(this.element);\r\n            } else {\r\n                this.classes.forEach(className => element.classList.add(className));\r\n                //мы обращаемся к element, к его classList и добавляем каждый класс который будет находится в массиве classes\r\n            }\r\n\r\n\r\n            //из верстки убрали  <div class=\"menu__item\"> после применения оператора rest\r\n\r\n            //реализации карточек с классом (059 вер 1), для второго варианта не нужно\r\n            element.innerHTML = `\r\n               \r\n                    <img src=${this.src} alt=${this.alt}>\r\n                    <h3 class=\"menu__item-subtitle\">${this.title}</h3>\r\n                    <div class=\"menu__item-descr\">${this.descr}</div>\r\n                    <div class=\"menu__item-divider\"></div>\r\n                    <div class=\"menu__item-price\">\r\n                        <div class=\"menu__item-cost\">Цена:</div>\r\n                        <div class=\"menu__item-total\"><span>${this.price}</span> грн/день</div> \r\n                    </div>\r\n                \r\n            `; // в this.price придет уже модифицир. значение, после конвертации\r\n            this.parent.append(element); //новосозданный элемент помещаем внутрь этого же элемента тк this.parent это дом элемент, то у него есть метод append\r\n        }\r\n    }\r\n\r\n    //Создание экземпляров класса:\r\n    /*  const div = new MenuCard();\r\n     div.render(); */\r\n\r\n    //альтернативная запись (сокращенная)\r\n    //new MenuCard().render(); объект и метод используются на месте, те он нам что то сделает и исчезнет, тк на него нет ссылок\r\n\r\n    //Функцию getResourse вынесли в отдельный файл services тк она работает с сервером и может также пригодится в других местах\r\n\r\n    /* //060.Создание карточек с помощью готовых библиотек\r\n        axios.get('http://localhost:3000/menu')\r\n            .then(data => {\r\n                data.data.forEach(({\r\n                    img,\r\n                    altimg,\r\n                    title,\r\n                    descr,\r\n                    price\r\n                }) => { // {img, altimg, title, descr, price} деструктуризировали объект\r\n                    new MenuCard(img, altimg, title, descr, price, '.menu .container').render();\r\n                });\r\n            }); */\r\n\r\n    //Реализация создания карточек с помощью конструктора классов (059 вер 1)\r\n    getResourse('http://localhost:3000/menu')\r\n        .then(data => {\r\n            data.forEach(({\r\n                img,\r\n                altimg,\r\n                title,\r\n                descr,\r\n                price\r\n            }) => { // {img, altimg, title, descr, price} деструктуризировали объект\r\n                new MenuCard(img, altimg, title, descr, price, '.menu .container').render();\r\n            });\r\n        });\r\n\r\n\r\n    //Реализация создания карточек без использования классов (059 вер 2)\r\n    //getResourse('http://localhost:3000/menu')\r\n    //   .then(data => createCard(data));\r\n\r\n    function createCard(data) { //функция createCard получает данные (массив), далее перебираем их и деструктуризируем объекты на отдельные свойства, далее создаем новый div, добавляем ему новый класс, формируем верстку и внутрь помещаем свойства которые пришли с сервера и вставляем (аппендим) карточку на страницу.\r\n        data.forEach(({\r\n            img,\r\n            altimg,\r\n            title,\r\n            descr,\r\n            price\r\n        }) => {\r\n            const element = document.createElement('div');\r\n            element.classList.add('menu__item');\r\n            element.innerHTML = `\r\n            <img src=${img} alt=${altimg}>\r\n            <h3 class=\"menu__item-subtitle\">${title}</h3>\r\n            <div class=\"menu__item-descr\">${descr}</div>\r\n            <div class=\"menu__item-divider\"></div>\r\n            <div class=\"menu__item-price\">\r\n                <div class=\"menu__item-cost\">Цена:</div>\r\n                <div class=\"menu__item-total\"><span>${price}</span> грн/день</div> \r\n            </div>\r\n            `;\r\n            document.querySelector('.menu .container').append(element);\r\n        });\r\n    }\r\n\r\n    /* //Не нужно для 059, тк данные получаем с сервера.  \r\n        //Настройка каждого отдельного элемента, который создадим\r\n        new MenuCard( //прописываем все в кавычках\r\n            //если забудем передать 'menu__item' то все равно сайт будет работать, тк мы создали условие в которое установили стандратное значение.\r\n            \"img/tabs/vegy.jpg\",\r\n            \"vegy\",\r\n            'Меню \"Фитнес\"',\r\n            'Меню \"Фитнес\" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. Продукт активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!',\r\n            9,\r\n            '.menu .container',\r\n            'menu__item',\r\n\r\n\r\n        ).render();\r\n\r\n        new MenuCard( //прописываем все в кавычках\r\n            \"img/tabs/elite.jpg\",\r\n            \"elite\",\r\n            'Меню “Премиум”',\r\n            'В меню “Премиум” мы используем не только красивый дизайн упаковки, но и качественное исполнение блюд. Красная рыба, морепродукты, фрукты - ресторанное меню без похода в ресторан!',\r\n            14,\r\n            '.menu .container',\r\n            'menu__item'\r\n\r\n        ).render();\r\n\r\n        new MenuCard( //прописываем все в кавычках\r\n            \"img/tabs/post.jpg\",\r\n            \"post\",\r\n            'Меню \"Постное\"',\r\n            'Меню “Постное” - это тщательный подбор ингредиентов: полное отсутствие продуктов животного происхождения, молоко из миндаля, овса, кокоса или гречки, правильное количество белков за счет тофу и импортных вегетарианских стейков.',\r\n            21,\r\n            '.menu .container',\r\n            'menu__item'\r\n\r\n        ).render(); */\r\n\r\n\r\n    //после создания карточек через JS, удаляем их из файла html\r\n}\r\n\r\nexport default cards;","import {closeModal, openModal} from './modal';\r\nimport {postData} from '../services/services';\r\nfunction forms(formSelector, modalTimerId) {\r\n    \r\n    //053 Forms. Реализация скрипта отправки данных на сервер с использование объекта XMLHttpRequest\r\n    // Сначала создаем файл backEnd - server.php\r\n    const forms = document.querySelectorAll(formSelector); //получение всех форм по тегу \"form\"\r\n    const message = { //создаем объект с различными свойствами - сообщениями\r\n        //loading: 'Загрузка',\r\n        loading: 'img/form/spinner.svg',\r\n        success: 'Спасибо! Скоро мы с вами свяжемся',\r\n        failure: 'Что то пошло не так...'\r\n    };\r\n\r\n    forms.forEach(item => { //под каждую форму подвязываем функцию bindPostData\r\n        bindPostData(item);\r\n    });\r\n\r\n    //059 Получение данных с сервера. Async_await\r\n\r\n    //Async_await превращает асинхронный код в синхронный\r\n    //При запуске функции postData начинает идти запрос и тк указано ключевое слово await браузеру необходимо дождаться результата этого запроса\r\n    //Если не прописать Async/await выйдет ошибка на шаге res.json(), тк из fetch ничего не вернулось, а мы будет пытаться обработать результат методом json\r\n    //async ставится перед функцией\r\n\r\n    //073.Функцию postData вынесли в отдельный файл services, тк она работает с сервером и может также пригодится в других местах\r\n\r\n    function bindPostData(form) { //привязать постинг данных\r\n        form.addEventListener('submit', (e) => { //событие submit срабатывает каждый раз когда мы пытаемся отправить форму\r\n            //по умолчанию браузер всегда перезагружает страницу при нажатии на клавишу с тегом btn \r\n            e.preventDefault(); //отмена перезагрузки страницы при нажатии на кнопки Перезвонить мне\r\n\r\n            let statusMessage = document.createElement('img'); //создаем элемент с сообщением\r\n            statusMessage.src = message.loading;\r\n            //statusMessage.textContent = message.loading; //После нажатия на кнопку выйдет сообщение Загрузка\r\n            statusMessage.style.cssText = `\r\n        display: block;\r\n        margin: 0 auto;\r\n        `;\r\n            //form.append(statusMessage); //добавить к форме текстовое поле\r\n            form.insertAdjacentElement('afterend', statusMessage);\r\n\r\n            /* Не неужно для Fetch (056)\r\n            const request = new XMLHttpRequest(); //создание объекта XMLHttpRequest\r\n            request.open('POST', 'server.php'); //вызываем метод open для настройки запроса */\r\n\r\n\r\n            //Отправка данных с форм в двух разных форматах:\r\n            //1) formData\r\n            //2) JSON\r\n            //Заголовок в случае (formData+XMLHttpRequest), при отправке форм устанавливать не нужно!!!\r\n            //request.setRequestHeader('Content-type', 'multipart/form-data');\r\n            //2) Для JSON нужен заголовок request.setRequestHeader('Content-type', 'application/json');\r\n\r\n            //request.setRequestHeader('Content-type', 'application/json'); 056 Fetch\r\n            //request.setRequestHeader(); //для Fetch заголовок перенесли \r\n\r\n            const formData = new FormData(form); //formData\r\n            //Для сбора информации с форм с помощью formData, \r\n            //необходимо чтобы у форм в верстке был всегда атбрибут name\r\n\r\n            //Превращение объекта formData в формат JSON Не нужно для 059, заменили другим.\r\n            //formData специфический объект и просто так мы не можем его прогнать в другой формат\r\n            /*  const object = {};\r\n             formData.forEach(function (value, key) { //перебор formData и помещение данных в object\r\n                 object[key] = value;\r\n             }); */\r\n            //На данном этапе получили обычный объект (object), а не formData\r\n            //const json = JSON.stringify(object); //превращение объекта в JSON \r\n\r\n            const json = JSON.stringify(Object.fromEntries(formData.entries()));\r\n            //formData собрала все данные с формы, мы ее превращаем в массив массивов, после этого превращаем в классический объект, а после этого классический объект превращаем в json.\r\n            //entries берет каждое свойство из объекта и формирует из него маленький массив\r\n\r\n\r\n            //request.send(formData); //метод для отправки 1)formData\r\n            // Не нужно для Fetch 056: \r\n            //request.send(json); //2) для JSON\r\n\r\n            postData('http://localhost:3000/requests', json)\r\n                //.then(data => data.text()) //модификация ответа от сервера в обычный текст. Не нужно для 059\r\n                .then(data => {\r\n                    console.log(data); //вывод в консоль того, что вернул сервер\r\n                    showThanksModal(message.success); //Сообщение об упехе\r\n                    statusMessage.remove();\r\n                }).catch(() => { //этот блок лучше всегда прописывать, чтобы обрабатывать ошибки\r\n                    showThanksModal(message.failure);\r\n                }).finally(() => { // вносится действие которое выполняется всегда\r\n                    form.reset(); //Очистка формы\r\n                });\r\n\r\n            /*     Не нужно для Fetch 056\r\n            request.addEventListener('load', () => {  //load - конечная загрузка запроса\r\n                    if (request.status === 200) {\r\n                        console.log(request.response);\r\n                        showThanksModal(message.success); //Сообщение об упехе\r\n                         //setTimeout(() => { //удалить блок с сообщение через 2 сек. \r\n                        statusMessage.remove();\r\n                        form.reset(); //Очистка формы\r\n                        //}, 2000); \r\n                    } else {\r\n                        showThanksModal(message.failure); //сообщение об ошибке\r\n                    }\r\n                });  */\r\n        });\r\n    }\r\n\r\n    //054.Красивое оповещение пользователя.\r\n    //После отправки формы с обратной связью пользователю будет выходить окно с благодарностью\r\n    function showThanksModal(message) {\r\n        const prevModalDialog = document.querySelector('.modal__dialog'); //находим модальное окно\r\n\r\n        prevModalDialog.classList.add('hide'); //скрытие модального окна с контентом\r\n        openModal('.modal', modalTimerId); //открытие модального окна\r\n\r\n        const thanksModal = document.createElement('div');\r\n        thanksModal.classList.add('modal__dialog'); //добавление класса новому окну, чтобы он нормально выглядел\r\n        //формирование верстки модального окна\r\n        thanksModal.innerHTML = `\r\n      <div class=\"modal__content\">\r\n        <div class=\"modal__close\" data-close>×</div>\r\n        <div class=\"modal__title\">${message}</div>\r\n      </div>\r\n    `;\r\n        //Убираем переменную modalCloseBtn и назначение обработчика события modalCloseBtn.addEventListener('click', closeModal);\r\n        document.querySelector('.modal').append(thanksModal);\r\n        setTimeout(() => {\r\n            thanksModal.remove(); //удалить окно с благодарностью\r\n            prevModalDialog.classList.add('show');\r\n            prevModalDialog.classList.remove('hide');\r\n            closeModal('.modal');\r\n        }, 1000);\r\n\r\n    }\r\n\r\n    /*   //056. Fetch API (application programming interface) интерфейс програмного обеспечения\r\n      Fetch это замена XMLHttpRequest\r\n      По - простому это набор данных и возможностей которые предоставляет нам какое то готовое решение.\r\n      Самый банальный API это DOM API, по факту это различные методы(к примеру querySelector), которые позволяют нам работать с элементами на странице\r\n      Перепишем наш функционал проекта с использование Fetch.\r\n      //Fetch технология позволяющая общаться с сервером, построенная на Промисах\r\n      https://jsonplaceholder.typicode.com/ база данных для тестов\r\n\r\n          //Обычный GET запрос\r\n          fetch('https://jsonplaceholder.typicode.com/todos/1') //возвращается промис\r\n          .then(response => response.json()) //response - ответ.\r\n          //response.json() превращает json данные в самый обычный JS объект. Эта команда возвращает нам промис, тк мы не знаем как быстро наш json объект превратится в обычный объект, не знаем точного количества времени. Если все успешно прошло, то выполняется следующий then.\r\n          .then(json => console.log(json));\r\n\r\n      //   2 способа запросов на сервер:\r\n      //   - XMLHttpRequest(XHR)\r\n      //   - Fetch\r\n\r\n      //POST запрос\r\n      fetch('https://jsonplaceholder.typicode.com/posts', { //Из этой конструкции возвращается именно Промис. Настройки Fetch идут после url в формате объекта. Если эти настройки не указывать, то это будет обычный GET запрос.\r\n              method: 'POST',\r\n              body: JSON.stringify({\r\n                  name: 'Alex'\r\n              }), //объект который будем отправлять, JSON.stringify преобразует строку или объект в JSON данные\r\n              headers: { //заголовки\r\n                  'Content-type': 'application/json'\r\n              }\r\n          })\r\n          .then(response => response.json())\r\n          .then(json => console.log(json));\r\n\r\n\r\n      PUT полное изменение ресурса\r\n      PATCH частичное изменение ресурса*/\r\n\r\n    //058. npm. JSON server\r\n    fetch('http://localhost:3000/menu') //прописали в терминале команду json-server db.json и после этого получили ссылку\r\n        .then(data => data.json())\r\n        .then(res => console.log(res));\r\n}\r\n\r\nexport default forms;","//closeModal и openModal вынесли из modal, тк эти функции используются еще и в других модулях (forms.js).\r\nfunction closeModal(modalSelector) {\r\n    const modal = document.querySelector(modalSelector);\r\n    modal.classList.add('hide');\r\n    modal.classList.remove('show');\r\n    document.body.style.overflow = '';\r\n}\r\n\r\nfunction openModal(modalSelector, modalTimerId) {\r\n    const modal = document.querySelector(modalSelector);\r\n    modal.classList.add('show');\r\n    modal.classList.remove('hide');\r\n    document.body.style.overflow = 'hidden';\r\n\r\n    console.log(modalTimerId);\r\n    if (modalTimerId) { //запускать clearInterval только если был передан modalTimerId\r\n        clearInterval(modalTimerId);\r\n    }\r\n    \r\n}\r\n\r\nfunction modal(triggerSelector, modalSelector, modalTimerId) {\r\n        //Modal\r\n    /*     Первым делом необходимо в HTML найти кнопки/триггеры которые будут вызывать модальное окно,\r\n        они могут иметь разные классы, теги и чтобы их как то объединить, пометить им назначают data атрибуты\r\n        <button data-modal class=\"btn btn_white\">Связаться с нами</button>\r\n        Также вешаем data атрибут на закрытие модального окна\r\n         <div data-close class=\"modal__close\">&times;</div> */\r\n\r\n    //Триггер для модального окна это будет кнопка \"Связаться с Нами\"\r\n    const modalTrigger = document.querySelectorAll(triggerSelector), //атрибут прописывается в квадратных скобках. Находим кнопки.\r\n        modal = document.querySelector(modalSelector); //переменная отвечающая за само модальное окно\r\n    //После создания мод. модального окна в 054, обработчик события работать с таким элементами не будет,\r\n    //тк элемент создан динамически с помощью JS. Удаляем переменную modalCloseBtn\r\n    //  modalCloseBtn = document.querySelector('[data-close]'); //кнопка отвечающая за закрытие окна\r\n\r\n\r\n\r\n    /*    modalTrigger.addEventListener('click', () => { //при клике на кнопку \"Связаться с нами\" выходит модальное окно\r\n           modal.classList.add('show');\r\n           modal.classList.remove('hide');\r\n           document.body.style.overflow = 'hidden'; //запрет прокрутки страницы при открытом модальном окне\r\n          });\r\n\r\n       modalCloseBtn.addEventListener('click', () => { //обратная операция, при нажатии на крестить в модальном окне, оно закрывается\r\n           modal.classList.add('hide'); //добавить класс скрытия\r\n           modal.classList.remove('show'); //удалить класс показа\r\n           document.body.style.overflow = ''; //при закрытии модального окна, восстановить скрол страницы\r\n       });   */\r\n\r\n\r\n    modalTrigger.forEach(btn => {\r\n        btn.addEventListener('click', () => openModal(modalSelector, modalTimerId));\r\n    }); //если не добавить стрелочную функцию, то openModal(modalSelector) вызовется сразу, а так делать нельзя. \r\n\r\n  \r\n\r\n    /* \r\n        // второй способ вызова модального окна, с помощью переключения класса:\r\n        modalTrigger.forEach(btn => { //необходимо кнопки перебрать тк мы не можем на псевдомассив повесить обработчик события\r\n            //перебор также нужен и для первого способа, чтобы повесить обработчик события на все кнопки\r\n            btn.addEventListener('click', openModal); //при клике на кнопку \"Связаться с нами\" выходит модальное окно\r\n        });\r\n\r\n        //если какой то участок кода повтораяется два и более раз, то его необходимо вынести в отдельную функцию\r\n        function openModal() {\r\n            modal.classList.toggle('show'); //переключить класс show (тк класса еще нет, то он его автоматически допишет)\r\n            document.body.style.overflow = 'hidden'; //запрет прокрутки страницы при открытом модальном окне\r\n            clearInterval(modalTimerId); //очищаем и останавливаем таймер, если пользователь сам уже открывал модальное окно.\r\n        }\r\n\r\n        function closeModal() { //функция закрытия модального окна\r\n            modal.classList.toggle('show'); // класс уже есть у окна, те при нажатии на кнопку класс удалится.\r\n            document.body.style.overflow = ''; //при закрытии модального окна, восстановить скрол страницы\r\n        }\r\n     */\r\n    //тк в 054 создаем элемент динамически, на нем не будет работать обработчик события\r\n    //modalCloseBtn.addEventListener('click', closeModal); //обратная операция, при нажатии на крестить в модальном окне, оно закрывается\r\n\r\n    modal.addEventListener('click', (e) => { //e.target это то, куда кликнул пользователь\r\n        //в 054 создаем динамически элемент, для его закрытия добавляем:\r\n        //e.target.getAttribute('data-close')\r\n        if (e.target === modal || e.target.getAttribute('data-close') == '') { //при клике в подложку (modal) окно также закрывается\r\n            //e.target === modal - клик на подложку\r\n            //e.target.getAttribute('data-close') - клик на крести в окне\r\n            closeModal(modalSelector); // в данном случае пишем со скобками, те условие выполнилось, функция выполняется\r\n        }\r\n    });\r\n\r\n    document.addEventListener('keydown', (e) => { //при нажатии на кнопку ESC окно также закрывается\r\n        //кода кнопок можно посмотреть на сайте https://keycode.info/\r\n        if (e.code === \"Escape\" && modal.classList.contains('show')) { //чтобы каждый раз при нажатии на ESC не вызывалась функция прописываем условие, что вызвать только когда модальное окно показано\r\n            closeModal(modalSelector);\r\n        }\r\n    });\r\n\r\n    //044 Модификации модального окна. \r\n    //Всплытие окна при долистывании страницы до конца и при прошестви некоторого времени\r\n\r\n    \r\n\r\n    function showModalByScroll() {\r\n        if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight) {\r\n            //если условие выполняется, то означает, что пользователь долистал до конца.\r\n            //свойство pageYOffset отслеживает сколько px отлистал поль-ль по оси Y (прокрученная часть)\r\n            //свойство scrollHeight получение полной высоты элемента с учетом прокрутки которая была сверху\r\n            //clientHeight высота клиента, те видимой части окна\r\n            openModal(modalSelector, modalTimerId);\r\n            window.removeEventListener('scroll', showModalByScroll); //как только пол-ль долистал один раз старцницу до конца, всплывет модальное окно и все, больше всплывать не будет.\r\n        }\r\n    }\r\n    window.addEventListener('scroll', showModalByScroll); //при долистывании страницы до конца появляется модальное окно\r\n}\r\n\r\nexport default modal;\r\nexport {closeModal};\r\nexport {openModal};","function slider({container, slide, nextArrow, prevArrow, totalCounter, currentCounter, wrapper, field}) { //073.используем деструктуризацию\r\n\r\n        //061-062.Создание слайдера на сайте. \r\n        const slides = document.querySelectorAll(slide),\r\n        slider = document.querySelector(container), //для 063\r\n        prev = document.querySelector(prevArrow),\r\n        next = document.querySelector(nextArrow),\r\n        total = document.querySelector(totalCounter),\r\n        current = document.querySelector(currentCounter),\r\n        slidesWrapper = document.querySelector(wrapper), //для 2 вар, главная обертка.\r\n        width = window.getComputedStyle(slidesWrapper).width, //для 2 вар, ширина отверстия/окошко через которое мы будем видеть наш слайд.\r\n        slidesField = document.querySelector(field); //для 2 вар, поле с нашими слайдами.\r\n       \r\n    let slideIndex = 1;\r\n\r\n    //062.Создание слайдера на сайте. 2 вариант.\r\n    //В файле html обернули слайды еще в один блок <div class=\"offer__slider-inner\">, делается это для того, чтобы главная обертка была как окошко, через которое мы можем видеть текущий слайд\r\n    let offset = 0; //для смещения слайдов, необходимо установить отступ.\r\n    if (slides.length < 10) {\r\n        total.textContent = `0${slides.length}`;\r\n        current.textContent = `0${slideIndex}`;\r\n    } else {\r\n        total.textContent = slides.length;\r\n        current.textContent = slideIndex;\r\n    }\r\n    slidesField.style.width = 100 * slides.length + '%'; //ширина блока со слайдами\r\n    slidesField.style.display = 'flex'; //изменяем свойство display, применяем flex чтобы все слайды выстроились в одну полоску\r\n    slidesField.style.transition = '0.5s all'; //добавляем свойство transition для плавного передвижения слайдов\r\n    slidesWrapper.style.overflow = 'hidden'; //скрываем все элементы которые не попадают в область видимости\r\n    slides.forEach(slide => { //берем все слайды, перебираем и каждому слайду установим одинаковую ширину \r\n        slide.style.width = width;\r\n    })\r\n\r\n    //063.Создание навигации по слайдам\r\n    slider.style.position = 'relative';\r\n    const indicators = document.createElement('ol'), //создали элемент с тегом ol (ordered list - упорядоченный список), а внутри каждый элемент li\r\n        dots = [];\r\n    indicators.classList.add('carousel-indicators');\r\n    indicators.style.cssText = `\r\n        position: absolute;\r\n        right: 0;\r\n        bottom: 0;\r\n        left: 0;\r\n        z-index: 15;\r\n        display: flex;\r\n        justify-content: center;\r\n        margin-right: 15%;\r\n        margin-left: 15%;\r\n        list-style: none;\r\n        `;\r\n    slider.append(indicators);\r\n    for (let i = 0; i < slides.length; i++) {\r\n        const dot = document.createElement('li'); //создаем элемент точки с тегом li\r\n        dot.setAttribute('data-slide-to', i + 1); //установить каждой точке атрибут и нумерацию начиная с единицы\r\n        dot.style.cssText = `\r\n            box-sizing: content-box;\r\n            flex: 0 1 auto;\r\n            width: 30px;\r\n            height: 6px;\r\n            margin-right: 3px;\r\n            margin-left: 3px;\r\n            cursor: pointer;\r\n            background-color: #fff;\r\n            background-clip: padding-box;\r\n            border-top: 10px solid transparent;\r\n            border-bottom: 10px solid transparent;\r\n            opacity: .5;\r\n            transition: opacity .6s ease;\r\n            `;\r\n\r\n        if (i == 0) {\r\n            dot.style.opacity = 1; //подсветка текущего индикатора слайдов\r\n        }\r\n\r\n        indicators.append(dot);\r\n        dots.push(dot); //поместили точку в массив\r\n    }\r\n    next.addEventListener('click', () => {\r\n        if (offset == deleteNoDigits(width) * (slides.length - 1)) {\r\n            //тк в width лежит строка с px (к примеру 500px), то необходимо отрезать два последних символа. Если наш отступ будет равен ширине одного слайда * на количество слайдов -1, то установить offset в ноль, это означает, что мы долистали до самого конца и нам необходимо вернуться в самое начало\r\n            offset = 0;\r\n        } else {\r\n            offset += deleteNoDigits(width); //добавляем к отступу ширину еще одного сладйа\r\n        }\r\n        slidesField.style.transform = `translateX(-${offset}px`; //трансформация элемента по оси Х, минус означает смещение влево.\r\n\r\n        if (slideIndex == slides.length) { //если дошли до конца слайдера, необходимо переместиться в первую позицию\r\n            slideIndex = 1;\r\n        } else {\r\n            slideIndex++;\r\n        }\r\n\r\n        /*  if (slides.length < 10) { \r\n             current.textContent = `0${slideIndex}`\r\n         } else {\r\n             current.textContent = slideIndex;\r\n         }\r\n         dots.forEach(dot => dot.style.opacity = '.5'); //для 063\r\n         dots[slideIndex - 1].style.opacity = 1; //для 063 */\r\n        setOpacity();\r\n        addZero();\r\n    });\r\n\r\n    prev.addEventListener('click', () => {\r\n        if (offset == 0) { //здесь мы уже проверяем не последний слайд, как в next, а первый.\r\n            offset = deleteNoDigits(width) * (slides.length - 1) //перемещаемся в самый конец. В offset записываем последний слайд.\r\n        } else {\r\n            offset -= deleteNoDigits(width); //отнимаем ширину слайда\r\n        }\r\n        slidesField.style.transform = `translateX(-${offset}px`\r\n\r\n        if (slideIndex == 1) {\r\n            slideIndex = slides.length;\r\n        } else {\r\n            slideIndex--;\r\n        }\r\n\r\n        /* if (slides.length < 10) {\r\n            current.textContent = `0${slideIndex}`\r\n        } else {\r\n            current.textContent = slideIndex\r\n        }\r\n\r\n        //063\r\n    \r\n        dots.forEach(dot => dot.style.opacity = '.5');\r\n        dots[slideIndex - 1].style.opacity = 1; */\r\n        setOpacity();\r\n        addZero();\r\n    })\r\n    dots.forEach(dot => {\r\n        dot.addEventListener('click', (e) => {\r\n            const slideTo = e.target.getAttribute('data-slide-to');\r\n            slideIndex = slideTo;\r\n            offset = deleteNoDigits(width) * (slideTo - 1);\r\n            slidesField.style.transform = `translateX(-${offset}px`;\r\n\r\n              /*  if (slides.length < 10) {\r\n                  current.textContent = `0${slideIndex}`;\r\n              } else {\r\n                  current.textContent = slideIndex;\r\n              }\r\n              \r\n              dots.forEach(dot => dot.style.opacity = '.5');\r\n              dots[slideIndex - 1].style.opacity = 1;  */\r\n            setOpacity();\r\n            addZero();\r\n        });\r\n    });\r\n\r\n    function setOpacity() {\r\n        dots.forEach(dot => dot.style.opacity = '.5');\r\n        dots[slideIndex - 1].style.opacity = 1; //подсветка точки активного слайда\r\n    }\r\n\r\n    function addZero() { //если слайдов меньше 10, добавляем к индексу ноль \r\n        if (slides.length < 10) {\r\n            current.textContent = `0${slideIndex}`;\r\n        } else {\r\n            current.textContent = slideIndex;\r\n        }\r\n    }\r\n\r\n    function deleteNoDigits(str) {\r\n        return +str.replace(/\\D/g, '')\r\n    }\r\n\r\n    /*   //061.Создание слайдера на сайте. 1 вариант.\r\n\r\n      showSlides(slideIndex);\r\n      if (slides.length < 10) {\r\n          total.textContent = `0${slides.length}`;\r\n      } else {\r\n          total.textContent = slides.length;\r\n      }\r\n\r\n      function showSlides(n) {\r\n          if (n > slides.length) {\r\n              slideIndex = 1;\r\n          }\r\n          if (n < 1) { //если при прокрутке слайдов уходим в отрицательную сторону, то просто перемещаемся в конец\r\n              slideIndex = slides.length;\r\n          }\r\n\r\n          slides.forEach(item => item.style.display = 'none');\r\n\r\n          slides[slideIndex - 1].style.display = 'block';\r\n\r\n          //   showSlides(slideIndex);\r\n          if (slides.length < 10) {\r\n              current.textContent = `0${slideIndex}`;\r\n          } else {\r\n              current.textContent = slideIndex;\r\n          }\r\n      }\r\n\r\n      function plusSlides(n) {\r\n          showSlides(slideIndex += n);\r\n      }\r\n\r\n      prev.addEventListener('click', () => {\r\n          plusSlides(-1)\r\n      });\r\n\r\n      next.addEventListener('click', () => {\r\n          plusSlides(1)\r\n      }); */\r\n\r\n}\r\n\r\nexport default slider;","function tabs(tabsSelector, tabsContentSelector, tabsParentSelector, activeClass) {\r\n    //Tabs\r\n    /*  3 задачи:\r\n     1)Функция которая будет скрывать ненужные нам табы\r\n     2)Функция показа нужного Таба\r\n     3)Назначить обработчик события на меню */\r\n    const tabs = document.querySelectorAll(tabsSelector), //получение всех вкладок на которые будем кликать, тк класс ставим точку\r\n        tabsContent = document.querySelectorAll(tabsContentSelector), //получение класса отвечающего за контент\r\n        tabsParent = document.querySelector(tabsParentSelector); //родитель который будет содержать все табы/вкладки\r\n\r\n    /* В реальных проектах чаще всего используют классы вместо inline стилей, исправим программу под это. В CSS добавили следующий код, для анимации и скрытия и показа вкладок, те используем класс вместо inline стилей\r\n    .show{display:block}.hide{display:none}.fade{animation-name: fade;animation-duration: 1.5s;}@keyframes fade{from{opacity: 0.1;}to{opacity: 1;}}\r\n    класс show для показа элемента, hide для скрытия, fade для анимании вкладок (табов), длится 1,5 сек, от прозрачности 10% до 100% */\r\n\r\n    function hideTabContent() { //функция скрывающая все ненужные табы\r\n        tabsContent.forEach(item => { //перебираем массив\r\n            // item.style.display = 'none'; используем inline стили\r\n            item.classList.add('hide'); //вместо inline стилей используем классы. Добавляем класс hide\r\n            item.classList.remove('show', 'fade'); //удалить класс show с анимацией\r\n        });\r\n        tabs.forEach(item => {\r\n            item.classList.remove(activeClass); //удалить у каждого элемента Таба класс активности, тк мы работаем с классами, команда classList, то точку не ставим.\r\n        });\r\n    }\r\n\r\n    function showTabContent(i = 0) { //если функция вызыватся без аргумента, то по умолчанию 0, те показ первого слайда.\r\n        //tabsContent[i].style.display = 'block'; используем inline стили, эту строку заменили на две нижестоящие.\r\n        tabsContent[i].classList.add('show', 'fade'); //вместо inline стилей используем классы. Добавляем класс show с анимацией\r\n        tabsContent[i].classList.remove('hide');\r\n        tabs[i].classList.add(activeClass);\r\n    }\r\n\r\n    hideTabContent();\r\n    showTabContent();\r\n\r\n    //Используем делигирование событий\r\n    tabsParent.addEventListener('click', (event) => {\r\n        const target = event.target; //необязательное, но желательное действие, можно было обращаться к event.target\r\n        //073.тк в classList используется значение без точки, те ее необходимо убрать\r\n        if (target && target.classList.contains(tabsSelector.slice(1))) { \r\n            tabs.forEach((item, i) => {\r\n                /*  мы переберем все табы которые лежат в переменной tabs и будем сравнивать\r\n                           если элемент который находится в этом псевдомассиве совпадает с элементом который кликнул пользователь, тогда мы берем его номер и показываем на странице \r\n                           item - каждый таб, i - номер по порядку который мы перебираем.\r\n                           target это тот элемент по которому мы только что кликнули */\r\n                if (target == item) { //если кликнутый элемент будет совпадать с элементом который мы перебираем то вызываем две функции\r\n                    hideTabContent(); //все табы скрываем\r\n                    showTabContent(i); //показываем нужный таб\r\n                }\r\n            });\r\n        }\r\n    });\r\n\r\n}\r\n\r\nexport default tabs;","function timer(id, deadline) {\r\n    \r\n    // Timer (Таймер, осталось до конца акции, обратный отсчет) 041\r\n    //1) должна быть какая то функция которая будет устанавливать наш таймер (те получать элементы и что то с ними делать)\r\n    //2) должна быть функция, определяющая разницу между временем конечным и текущим у пользователя.\r\n    //3) функция которая занимается обновлением нашего таймера\r\n    //const deadline = '2021-06-13'; //дата обратного отсчета\r\n    function getTimeRemainning(endtime) { //функция определяющая разницу между датами\r\n        const t = Date.parse(endtime) - Date.parse(new Date()), //преобразуем даты в число (количество миллисекунд). \r\n            //делим количество миллисекунд на кол-во млсек в 1 дне\r\n            days = Math.floor(t / (1000 * 60 * 60 * 24)), //определить количество дней отображаемых в обратном таймере Math.floor округление до ближайшего целого\r\n            // 1000*60*60*24 - столько в сутках миллисекунд\r\n            hours = Math.floor((t / (1000 * 60 * 60) % 24)), //определяем количество целых часов до конца.\r\n            //1000*60*60 столько миллисекунд в часе (1000 милли секунд в секунде). t / (1000 * 60 * 60) - общее количество часов которое осталось, те там может быть и  150 и 300, нам это не нужно.\r\n            // % 24 - деление на 24 и возвращение остатка от деления. \r\n            minutes = Math.floor((t / 1000 / 60) % 60),\r\n            seconds = Math.floor((t / 1000) % 60);\r\n        //Для того чтобы вышеперечисленные переменные были видны и снаружи, необходимо использовать return\r\n        return { //возвращаем из функции объект\r\n            'total': t,\r\n            'days': days,\r\n            'hours': hours,\r\n            'minutes': minutes,\r\n            'seconds': seconds\r\n        };\r\n    }\r\n\r\n    function getZero(num) { //функция которая добавляет ноль впереди числу, если оно меньше 10\r\n        if (num >= 0 && num < 10) { //число должно быть больше или равно 0 и меньше чем двухзначное 10\r\n            return `0${num}`; //если условие произошло, то из функции возвращаем модифицированное значение\r\n        } else { //если число двухзначное, то возвращаем число без изменений\r\n            return num;\r\n        }\r\n    }\r\n\r\n    function setClock(selector, endtime) { //установка часов\r\n        const timer = document.querySelector(selector), //вместо selector можно указать и .timer, но мы дклаем общую функцию\r\n            days = timer.querySelector('#days'),\r\n            hours = timer.querySelector('#hours'),\r\n            minutes = timer.querySelector('#minutes'),\r\n            seconds = timer.querySelector('#seconds'),\r\n            timeInterval = setInterval(updateClock, 1000); //обновление таймера кажду секунду\r\n\r\n        updateClock(); //вызвать функцию вручную, чтобы цифры счетчика встали сразу корректные, а если этого не сделать сначала появятся цифры по умолчанию, и только через 1 сек счетчик.\r\n\r\n        function updateClock() { //создаем функцию которая будет обновлять наш таймер\r\n            const t = getTimeRemainning(endtime); //расчет времени которое осталось, здесь getTimeRemainning возвратит объект со всеми данными\r\n            //вставка расчетных значений на страницу\r\n            days.innerHTML = getZero(t.days); //getZero служит для того чтобы дописать ноль впереди цифры\r\n            hours.innerHTML = getZero(t.hours);\r\n            minutes.innerHTML = getZero(t.minutes);\r\n            seconds.innerHTML = getZero(t.seconds);\r\n\r\n            if (t.total <= 0) { //если время вышло и оно идет в отрицательную сторону, то таймер не обновляем\r\n                clearInterval(timeInterval);\r\n            }\r\n        }\r\n    }\r\n    setClock(id, deadline); //первая переменная это selector\r\n}\r\n\r\nexport default timer;","//Тк функции postDate и getResourse работают с сервером и могут пригодится в разных местах, то их обычно выносят в отдельную папку и файлы и называют сервисами.\r\n\r\n//Async_await превращает асинхронный код в синхронный\r\n//При запуске функции postDate начинает идти запрос и тк указано ключевое слово await браузеру необходимо дождаться результата этого запроса\r\n//Если не прописать Async/await выйдет ошибка на шаге res.json(), тк из fetch ничего не вернулось, а мы будет пытаться обработать результат методом json\r\n//async ставится перед функцией\r\nconst postData = async (url, data) => { //функция Function expression. data это то, что мы отправляем на сервер.\r\n    const res = await fetch(url, { //это асинхронный код, тк мы не знаем через сколько ответит сервер, но тк прописан await JS будет ждать результата зпроса.\r\n        method: 'POST', //настройка каким образом\r\n        headers: { //для отправки  formData, headers не нужно\r\n            'Content-type': 'application/json' //ставим не запятую, а двоеточие\r\n        },\r\n        body: data //настройка что именно отправлять\r\n    });\r\n\r\n    return await res.json(); //функция возвращает ответ-промис, который трансформируется в формат json, но тк мы не знаем насколько большой объект и сколько времени займет трансформация следовательно указываем слово await\r\n\r\n};\r\n\r\n\r\nconst getResourse = async (url) => { //функция Function expression\r\n    const res = await fetch(url);\r\n    if (!res.ok) {\r\n        throw new Error(`Could not fetch ${url}, status: ${res.status}`); //для того чтобы ошибка выпала из нашей функции используем оператор throw\r\n    }\r\n    return await res.json(); //функция возвращает промис, который трансформируется в формат json\r\n};\r\n\r\nexport {postData};\r\n\r\nexport {getResourse};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import tabs from './modules/tabs';\r\nimport modal from './modules/modal';\r\nimport timer from './modules/timer';\r\nimport cards from './modules/cards';\r\nimport calc from './modules/calc';\r\nimport forms from './modules/forms';\r\nimport slider from './modules/slider';\r\nimport {openModal} from './modules/modal';\r\n//импорты выносим в самое начало кода\r\n\r\nwindow.addEventListener('DOMContentLoaded', () => {\r\n\r\n    const modalTimerId = setTimeout(() => openModal('.modal', modalTimerId), 60000); //через 6 сек откроется модальное окно, если он ранее его не открывал\r\n    tabs('.tabheader__item', '.tabcontent', '.tabheader__items', 'tabheader__item_active');\r\n    modal('[data-modal]', '.modal', modalTimerId);\r\n    timer('.timer', '2021-09-13');\r\n    cards();\r\n    calc();\r\n    forms('form', modalTimerId);\r\n    slider({ //передаем объект с настройками, благодаря деструктуризации, порядок свойств не имеет значения\r\n        container: '.offer__slider',\r\n        nextArrow: '.offer__slider-next',\r\n        prevArrow: '.offer__slider-prev',\r\n        slide: '.offer__slide',\r\n        totalCounter: '#total',\r\n        currentCounter: '#current',\r\n        wrapper: '.offer__slider-wrapper',\r\n        field: '.offer__slider-inner'\r\n    });\r\n\r\n});"],"names":[],"sourceRoot":""}